# StorySwarm Integration Analysis - Beats-Only Mode

**Date:** 2026-01-28
**Status:** Proposed Changes Review
**Purpose:** Analyze impact of StorySwarm beats-only mode on StoryArt workflow

---

## Executive Summary

StorySwarm proposes a **"beats-only mode"** to eliminate redundant prompt generation:
- **StoryArt**: Creates beats with metadata (current) → Optionally SKIP prompt generation (new)
- **StorySwarm**: Fetches beats from Redis → Generates rich narrative prompts using 6-agent pipeline

**Key Benefit:** StorySwarm's visual prompt pipeline (Director → Cinematographer → Stylist → SetDesigner → PromptWeaver) produces **richer, more narrative prompts** than StoryArt's current single-pass generation.

---

## Current State Analysis

### StoryArt's Current Workflow

```
User uploads Episode 2 script
    ↓
Beat Analysis (geminiService.ts)
    • Create 12-20 beats per scene
    • Assign imageDecision: NEW_IMAGE / REUSE_IMAGE
    • Generate metadata
    ↓
Prompt Generation (promptGenerationService.ts)
    • Generate positive/negative prompts for each beat
    • Use character/location overrides from database
    • Single-pass generation (Gemini/Claude/Qwen)
    ↓
Save to Redis (storyart:session:{timestamp})
    • analyzedEpisode with beats + prompts
    ↓
SwarmUI Image Generation
    • Use prompts from Redis
    • Generate images
```

### StorySwarm's Proposed Workflow

```
Fetch beats from Redis (FetchPromptsFromRedis)
    • Filter beats with imageDecision: NEW_IMAGE
    • Extract beat metadata (no prompts yet)
    ↓
Visual Prompt CEO Pipeline
    • Director Agent: Emotional vision + focal points
    • Cinematographer Agent: Shot type + lighting + framing
    • Stylist Agent: Character appearance + LoRA triggers
    • SetDesigner Agent: Database location artifacts
    ↓
Prompt Weaver Agent
    • Synthesize all outputs into narrative prose
    • Replace character names with LoRA triggers (JRUMLV, HSCEIA)
    • Weave into rich visual description (>100 tokens)
    ↓
Image Generation CEO → ComfyUI
    • Execute prompt
    • Generate image
```

---

## Proposed Changes to StoryArt

### 1. Add Configuration Mode Flag

**Location:** `E:\REPOS\storyart\.env`

```env
# Prompt Generation Mode
PROMPT_GENERATION_MODE=storyart  # or "storyswarm"
```

**Or per-session:**
```typescript
// In analyzeScript function
analyzeEpisode(episodeId, {
  promptMode: "storyswarm"  // Skip prompt generation
})
```

### 2. Conditional Prompt Generation

**Location:** `E:\REPOS\storyart\services\geminiService.ts` (line ~400)

```typescript
// After beat analysis completes
const analyzedEpisode = await parseGeminiResponse(jsonString);

// NEW: Check mode
const promptMode = process.env.PROMPT_GENERATION_MODE || 'storyart';

if (promptMode === 'storyart') {
  // Current behavior: generate prompts
  onProgress?.('Generating prompts...');
  await generatePromptsForBeats(analyzedEpisode, episodeContext);
} else {
  // Beats-only mode: skip prompt generation
  onProgress?.('Skipping prompt generation (storyswarm mode)');
  console.log('[Gemini] Beats-only mode - prompts will be generated by StorySwarm');
}

return analyzedEpisode;
```

### 3. Update Redis Schema (Conditional)

**Current schema (with prompts):**
```json
{
  "beatId": "s2-b7",
  "scriptText": "Cat types furiously...",
  "imageDecision": "NEW_IMAGE",
  "characters": ["cat-uuid"],
  "locationId": "trailer-uuid",
  "prompt": {
    "positive": "JRUMLV woman typing...",
    "negative": "blurry, distorted..."
  }
}
```

**Beats-only schema (no prompts):**
```json
{
  "beatId": "s2-b7",
  "scriptText": "Cat types furiously at the terminal...",
  "imageDecision": "NEW_IMAGE",
  "characters": ["cat-uuid"],
  "locationId": "trailer-uuid",
  "emotionalTone": "desperate tension",
  "visualElements": ["keyboard", "warning lights", "sweat"],
  "shotSuggestion": "medium close-up",
  "cameraAngleSuggestion": "slightly elevated looking down",
  "characterPositioning": "hunched over terminal"
  // NO prompt field
}
```

---

## Quality Comparison

### StoryArt Current Prompts (Single-Pass)

**Example from Episode 2:**
```
Positive: "JRUMLV woman relaxed, dark brown hair in practical ponytail,
green eyes, wearing form fitting white cotton halter top and camo tactical
pants, lean athletic build, soft natural lighting"

Negative: "blurry, low quality, distorted faces, extra limbs, cartoon..."
```

**Characteristics:**
- Factual and accurate
- Database-driven (character overrides)
- Consistent LoRA triggers
- **Issue:** Somewhat generic, lacks narrative context

### StorySwarm Multi-Agent Prompts (Proposed)

**Same beat through StorySwarm pipeline:**
```
Positive: "JRUMLV woman hunched over a flickering console in cramped
trailer interior, harsh fluorescent light casting shadows across her
sweat-stained tactical shirt as her fingers fly desperately across the
keyboard, warning lights pulsing red in the background, dark brown hair
escaping from practical ponytail, green eyes intense with focus, medium
close-up shot slightly elevated looking down, shallow depth of field with
blurred server racks in background, atmosphere of desperate tension"

Negative: "blurry, distorted faces, bright cheerful colors, fantasy
elements, unrealistic proportions, peaceful setting, relaxed postures,
bright cheerful lighting"
```

**Characteristics:**
- Rich narrative prose (>100 tokens)
- Emotional subtext included ("desperate", "intense")
- Technical specs woven in (shot type, lighting, DOF)
- Scene-specific negatives ("peaceful setting" negated for tense scene)

---

## Benefits of StorySwarm Mode

### 1. Richer Visual Prompts
- 6 specialized agents vs 1 prompt generation call
- Narrative prose vs template-based
- Emotional subtext captured
- Technical cinematography included

### 2. Database Canon Integrity
- SetDesigner Agent ensures ONLY database artifacts used
- No hallucinated location details
- StrictER adherence to visual canon

### 3. Character Continuity
- Stylist Agent tracks appearance across beats
- Detects costume/prop changes from script
- Maintains state between beats

### 4. Separation of Concerns
- StoryArt: Beat creation, narrative structure
- StorySwarm: Visual interpretation, prompt synthesis
- Each system does what it does best

---

## Implementation Impact Analysis

### Files to Modify in StoryArt

| File | Changes | Complexity |
|------|---------|------------|
| `.env` | Add `PROMPT_GENERATION_MODE` | Low |
| `services/geminiService.ts` | Add conditional prompt generation | Low |
| `services/pipelineClientService.ts` | Pass mode flag through pipeline | Low |
| `components/OutputPanel.tsx` | Show mode indicator in UI | Low |

### Backward Compatibility

**100% backward compatible:**
- Default mode: `PROMPT_GENERATION_MODE=storyart`
- Existing workflows unchanged
- Can switch modes per-session or globally

### Performance Implications

**StoryArt mode (current):**
- Beat analysis: ~2-3 min
- Prompt generation: ~1-2 min
- **Total: 3-5 min**

**StorySwarm mode (new):**
- Beat analysis: ~2-3 min
- StorySwarm prompt pipeline: ~30-60 sec (6 agents)
- **Total: 2.5-4 min** (potentially faster!)

---

## Testing Strategy

### Phase 1: Add Mode Flag
```bash
# Test backward compatibility
PROMPT_GENERATION_MODE=storyart npm run dev
# Should work exactly as before

# Test beats-only mode
PROMPT_GENERATION_MODE=storyswarm npm run dev
# Should skip prompt generation
```

### Phase 2: StorySwarm Integration
1. Analyze Episode 2 in beats-only mode
2. Check Redis: beats WITHOUT prompts
3. Call StorySwarm API to generate prompts
4. Compare prompt quality
5. Generate images using StorySwarm prompts

### Phase 3: Quality Comparison
- Generate same scene with both modes
- Compare prompt richness
- Compare final image quality
- Measure generation time

---

## Recommendations

### ✅ DO Implement This

**Reasons:**
1. **Better Quality**: StorySwarm's multi-agent pipeline produces richer prompts
2. **Zero Risk**: Backward compatible, can switch back anytime
3. **Clean Architecture**: Separation of concerns
4. **Low Effort**: ~2-3 hours implementation in StoryArt

### Implementation Priority

**Phase 1 (Immediate - 2 hours):**
- Add mode flag to `.env`
- Add conditional logic in `geminiService.ts`
- Test both modes work

**Phase 2 (After StorySwarm ready - 1 hour):**
- Integrate StorySwarm API call
- Test end-to-end with Episode 2
- Compare quality

**Phase 3 (Production - ongoing):**
- Monitor quality improvements
- Collect feedback
- Potentially make `storyswarm` default

---

## Questions to Resolve

1. **Should we keep both modes long-term?**
   - Recommend: Yes, some users may prefer faster single-pass prompts

2. **How to handle existing Redis sessions with prompts?**
   - StorySwarm already handles both schemas (checks for prompt field)

3. **What if StorySwarm is unavailable?**
   - Fallback to StoryArt mode automatically
   - Or queue for retry

4. **Can we use StorySwarm prompts to improve StoryArt's prompt generation?**
   - Yes! Analyze StorySwarm outputs to enhance StoryArt's templates

---

## Next Steps

1. **Review this analysis** - Confirm approach
2. **Implement mode flag** in StoryArt
3. **Test beats-only mode** with current Episode 2 run
4. **Coordinate with StorySwarm** - When is API ready?
5. **Run quality comparison** - Same beat, both modes

---

**This integration will significantly improve prompt quality with minimal risk and low implementation effort.**
